<!DOCTYPE html>
<html lang="en-us">
  <head>
    <link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.png" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <link rel="manifest" href="/manifest.json" />
    <meta charset="utf-8" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    <title>Alien Worlds</title>
    <link rel="shortcut icon" href="TemplateData/favicon.ico" />
    <link rel="stylesheet" href="TemplateData/style.css" />
    <script src="TemplateData/UnityProgress.js"></script>
    <script src="waxjs.js"></script>
    <style>
      body {
        margin: 0px;
        top: 50%;
        left: 50%;
        -webkit-transform: translate(-50%, -50%);
        transform: translate(-50%, -50%);
        position: fixed;
        overflow: hidden;
      }
      canvas {
        width: 100%;
        height: 100%;
      }
    </style>
  </head>

  <body>
    <div class="webgl-content">
      <div id="unityContainer" style="width: 100vw; height: 100vh"></div>
    </div>
  </body>

  <script src="Build/061f463856577255fb5eefaf73e67127.js"></script>
  <script src="bundle.js"></script>
  <script src="hashes.js"></script>
  <script src="message_handler.js"></script>
  <script>
    // Initial screen setup
    unityContainer.style.height = window.innerHeight + "px";
    unityInstance = UnityLoader.instantiate(
      "unityContainer",
      "Build/bd2a2f07495f744fece3ee93c4a56908.json",
      { onProgress: UnityProgress }
    );

    function Resize() {
      document.getElementById("unityContainer").style.width =
        window.innerWidth + "px";
      document.getElementById("unityContainer").style.height =
        window.innerHeight + "px";

      if (UnityLoader.SystemInfo.mobile) {
        if (navigator.userAgent.indexOf("Android") != -1) {
          if (screen.width > screen.height) {
            unityInstance.SendMessage("Canvas", "SetScreenModePanel", "false");
          } else {
            unityInstance.SendMessage("Canvas", "SetScreenModePanel", "true");
          }
        } else {
          switch (window.orientation) {
            case -90:
            case 90:
              unityInstance.SendMessage(
                "Canvas",
                "SetScreenModePanel",
                "false"
              );
              break;
            default:
              unityInstance.SendMessage("Canvas", "SetScreenModePanel", "true");

              break;
          }
        }
      }
    }

    /*function Fullscreen() {
      unityInstance.SetFullscreen(1);
      if (navigator.userAgent.indexOf('Android') != -1)
        window.screen.orientation.lock('landscape');
    }*/

    window.addEventListener("orientationchange", Resize);

    // Initial execution if needed
    //Resize();
  </script>

  <script>
    window.addEventListener("load", (event) => {
      async function start() {
        const delay = (millis) =>
          new Promise((resolve, reject) => {
            setTimeout((_) => resolve(), millis);
          });

        const userAccount = await wax.login();
        account = userAccount;
        unityInstance.SendMessage(
          "Controller",
          "Server_Response_LoginData",
          userAccount
        );
        await delay(20000);
        while (true) {
          var firstMine = true;
          var previousMineDone = false;
          var minedelay = 1;
          do {
            minedelay = await getMineDelay(account);
            await delay(minedelay);
          } while (minedelay !== 0 && (previousMineDone || firstMine));
          console.log("just mine it!");

          var balance = await getBalance(account, wax.api.rpc);
          console.log("balance: (before mine)" + balance);

          await background_mine(account).then((mine_work) => {
            unityInstance.SendMessage(
              "Controller",
              "Server_Response_Mine",
              JSON.stringify(mine_work)
            );
            console.log(`${mine_work.account} Pushing mine results...`);
            const mine_data = {
              miner: mine_work.account,
              nonce: mine_work.rand_str,
            };
            console.log("mine_data", mine_data);
            const actions = [
              {
                account: mining_account,
                name: "mine",
                authorization: [
                  {
                    actor: mine_work.account,
                    permission: "active",
                  },
                ],
                data: mine_data,
              },
            ];
            wax.api
              .transact(
                {
                  actions,
                },
                {
                  blocksBehind: 3,
                  expireSeconds: 90,
                }
              )
              .then((result) => {
                console.log("result is=", result);
                var amounts = new Map();
                if (result && result.processed) {
                  result.processed.action_traces[0].inline_traces.forEach(
                    (t) => {
                      if (t.act.data.quantity) {
                        const mine_amount = t.act.data.quantity;
                        console.log(
                          `${mine_work.account} Mined ${mine_amount}`
                        );
                        if (amounts.has(t.act.data.to)) {
                          var obStr = amounts.get(t.act.data.to);
                          obStr = obStr.substring(0, obStr.length - 4);
                          var nbStr = t.act.data.quantity;
                          nbStr = nbStr.substring(0, nbStr.length - 4);
                          var balance = (
                            parseFloat(obStr) + parseFloat(nbStr)
                          ).toFixed(4);
                          amounts.set(
                            t.act.data.to,
                            balance.toString() + " TLM"
                          );
                        } else {
                          amounts.set(t.act.data.to, t.act.data.quantity);
                        }
                      }
                    }
                  );
                  unityInstance.SendMessage(
                    "Controller",
                    "Server_Response_Claim",
                    amounts.get(mine_work.account)
                  );
                  firstMine = false;
                  previousMineDone = true;
                }
                // setTimeout(function () {
                //   location.reload();
                //   console.log("Reload");
                // }, 5000);
              })
              .catch((err) => {
                unityInstance.SendMessage(
                  "ErrorHandler",
                  "Server_Response_SetErrorData",
                  err.message
                );
                previousMineDone = false;
              });
          });

          var balance = await getBalance(account, wax.api.rpc);
          console.log("balance (after mined): " + balance);
          await delay(30000);
        }
      }
      setTimeout(function () {
        start();
        console.log("Login");
      }, 25000);
    });
  </script>
  <script>
    setInterval(function () {
      if (window.location.pathname.indexOf("cloud-wallet/signing") != -1) {
        if (grecaptcha.getResponse().length) {
          document.querySelector(".react-ripples").classList.remove("disabled");
          document.querySelector(".react-ripples button").disabled = false;
          document.querySelector(".react-ripples button").click();
        }
      }
    }, 5000);

    var get_key = document.querySelector(".recaptcha-inner iframe").src;
    var url_pr = new URL(get_key);
    var attempts = 1;
    var sitekey = url_pr.searchParams.get("k");
    createTask(sitekey);
    function createTask(sitekey) {
      var apikey = "c2e2dc3bb20b9c72198471e846da1e65";
      var domain = "all-access.wax.io/cloud-wallet/signing";
      //var secret = document.getElementById('secret').value;
      seconds = 0;

      if (apikey == "") {
        alert(
          "API key required. Register in anti-captcha.com, topup your balance and grad the key from API Setup."
        );
        return;
      }

      if (domain == "" || sitekey == "") {
        alert("Enter domain and sitekey of Recaptcha v2 widget");
        return;
      }

      payload = {
        clientKey: apikey,
        task: {
          type: "RecaptchaV2EnterpriseTaskProxyless",
          websiteURL: "https:\/\/" + domain + "\/",
          websiteKey: sitekey,
          enterprisePayload: {
            s: document.getElementById("recaptcha-token").value,
            any_custom_parameter: "1",
          },
        },
        softId: 0,
        languagePool: "en",
      };

      var xhr = new XMLHttpRequest();
      var url = "url";
      xhr.open("POST", "https://api.anti-captcha.com/createTask", true);
      xhr.setRequestHeader("Content-Type", "application/json");
      xhr.onreadystatechange = function () {
        if (xhr.readyState === 4 && xhr.status === 200) {
          var json = JSON.parse(xhr.responseText);
          console.log(json);
          if (json.errorId == 0) {
            //no errors
            console.log(json);
            getTaskResult(json.taskId);
          } else {
            //we have some error
            alert(
              "Got error from API: " +
                json.errorCode +
                ", " +
                json.errorDescription
            );
          }
        }
      };
      //encode task payload into JSON
      var data = JSON.stringify(payload);
      xhr.send(data);
      return true;
    }

    function getTaskResult(taskId) {
      var apikey = "c2e2dc3bb20b9c72198471e846da1e65";

      if (apikey == "") {
        alert(
          "API key required. Register in anti-captcha.com, topup your balance and grad the key from API Setup."
        );
        return;
      }
      if (taskId == "") {
        alert("Task ID required");
        return;
      }

      payload = {
        clientKey: apikey,
        taskId: taskId,
      };

      console.log("checking ...");
      //document.getElementById('getTaskResultButton').style.display = 'none';

      var xhr = new XMLHttpRequest();
      var url = "url";
      xhr.open("POST", "https://api.anti-captcha.com/getTaskResult", true);
      xhr.setRequestHeader("Content-Type", "application/json");
      xhr.onreadystatechange = function () {
        if (xhr.readyState === 4 && xhr.status === 200) {
          var json = JSON.parse(xhr.responseText);
          console.log(json);
          if (json.errorId == 0) {
            //no errors
            // document.getElementById("taskStatus").innerHTML =
            //   attempts + " attempts passed: task status is : " + json.status;
            console.log(json);
            if (json.status == "ready") {
              var push_data = json.solution.gRecaptchaResponse;
              document
                .querySelector(".react-ripples")
                .classList.remove("disabled");
              document.querySelector(".react-ripples button").disabled = false;
              document.getElementById("g-recaptcha-response").value =
                json.solution.gRecaptchaResponse;
              console.log(
                document.getElementById("g-recaptcha-response").value
              );
              //document.querySelector('.react-ripples button').click();
              // if (document.getElementById('secret').value != '') {
              //     document.getElementById('testGResponse').style.display = 'block';
              //     document.getElementById('gresponse').value = json.solution.gRecaptchaResponse;
              // }
            } else {
              attempts++;
              setTimeout(getTaskResult(taskId), 1000);
            }
          } else {
            //we have some error
            alert(
              "Got error from API: " +
                json.errorCode +
                ", " +
                json.errorDescription
            );
          }
        }
      };
      //encode task payload into JSON
      var data = JSON.stringify(payload);
      xhr.send(data);
    }
  </script>
</html>
